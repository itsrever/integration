/*
 * Integration stubs
 *
 * Stubs for implementing a REVER integration
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

// IntegrationLineItem - One of the line items from the Order
type IntegrationLineItem struct {

	// Optional customer comments/notes for the line item
	Comment string `json:"comment,omitempty"`

	// Id of the line item in the source platform. Must be unique within the order.
	Id string `json:"id"`

	// Name of the line item (not necessarily the name of the product). If possible, in the customer `preferred_lang`
	Name string `json:"name"`

	Product IntegrationProduct `json:"product"`

	// number of items of the same product and variant
	Quantity int32 `json:"quantity"`

	Subtotal IntegrationLineItemSubtotal `json:"subtotal"`

	Total IntegrationLineItemTotal `json:"total"`

	TotalDiscounts IntegrationLineItemTotalDiscounts `json:"total_discounts"`

	TotalTaxes IntegrationLineItemTotalTaxes `json:"total_taxes"`

	UnitPrice IntegrationLineItemUnitPrice `json:"unit_price"`

	// Variant ID of the product. The same Product ID can have different variants but they  must be listed in a different line item. A Variant can be the size: S, M, L, XL, etc. Only one variant ia allowed at the moment (one dimension). The `variant_id` must exist in the `variants` array of the `product` object.
	VariantId string `json:"variant_id,omitempty"`

	// Name of the variant, in the customer preferred language
	VariantName string `json:"variant_name,omitempty"`

	// weight for products from the order, measured in grams
	Weight int32 `json:"weight,omitempty"`
}

// AssertIntegrationLineItemRequired checks if the required fields are not zero-ed
func AssertIntegrationLineItemRequired(obj IntegrationLineItem) error {
	elements := map[string]interface{}{
		"id": obj.Id,
		"name": obj.Name,
		"product": obj.Product,
		"quantity": obj.Quantity,
		"subtotal": obj.Subtotal,
		"total": obj.Total,
		"total_discounts": obj.TotalDiscounts,
		"total_taxes": obj.TotalTaxes,
		"unit_price": obj.UnitPrice,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertIntegrationProductRequired(obj.Product); err != nil {
		return err
	}
	if err := AssertIntegrationLineItemSubtotalRequired(obj.Subtotal); err != nil {
		return err
	}
	if err := AssertIntegrationLineItemTotalRequired(obj.Total); err != nil {
		return err
	}
	if err := AssertIntegrationLineItemTotalDiscountsRequired(obj.TotalDiscounts); err != nil {
		return err
	}
	if err := AssertIntegrationLineItemTotalTaxesRequired(obj.TotalTaxes); err != nil {
		return err
	}
	if err := AssertIntegrationLineItemUnitPriceRequired(obj.UnitPrice); err != nil {
		return err
	}
	return nil
}

// AssertRecurseIntegrationLineItemRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of IntegrationLineItem (e.g. [][]IntegrationLineItem), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseIntegrationLineItemRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aIntegrationLineItem, ok := obj.(IntegrationLineItem)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertIntegrationLineItemRequired(aIntegrationLineItem)
	})
}
