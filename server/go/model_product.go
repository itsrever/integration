/*
 * Integration stubs
 *
 * Stubs for implementing a REVER integration
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

// Product - A product from the e-commerce catalog (enabled or not). Products that are removed from the catalog should still be available in the orders.
type Product struct {

	Categories []Category `json:"categories,omitempty"`

	// Product description
	Description string `json:"description,omitempty"`

	// Unique identifier for this resource in the source platform
	Id string `json:"id"`

	// Images associated to the product
	Images []Image `json:"images,omitempty"`

	// Product name
	Name string `json:"name"`

	UnitPrice ProductUnitPrice `json:"unit_price"`

	// Product short description
	ShortDescription string `json:"short_description,omitempty"`

	// stock-keeping unit (SKU) is a scannable bar code, most often seen printed on product labels in a retail store. Should be present if there are no variants.
	Sku string `json:"sku,omitempty"`

	// Optional inventory quantity. Overridden if there are variants defined. This field is not in use yet but it will be in the future for offering exchanges not based in  variants. 
	InventoryQuantity int32 `json:"inventory_quantity,omitempty"`

	// Optional tags associated to the product. They can be used to mark it as non-returnable.
	Tags []Tag `json:"tags,omitempty"`

	// All of the available product variations (if any). This is useful for offering exchanges of variants. If a `line_item`` references a variation, the attributes of the variation have to be used instead of the ones of the product
	Variants []Variant `json:"variants,omitempty"`
}

// AssertProductRequired checks if the required fields are not zero-ed
func AssertProductRequired(obj Product) error {
	elements := map[string]interface{}{
		"id": obj.Id,
		"name": obj.Name,
		"unit_price": obj.UnitPrice,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	for _, el := range obj.Categories {
		if err := AssertCategoryRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Images {
		if err := AssertImageRequired(el); err != nil {
			return err
		}
	}
	if err := AssertProductUnitPriceRequired(obj.UnitPrice); err != nil {
		return err
	}
	for _, el := range obj.Tags {
		if err := AssertTagRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Variants {
		if err := AssertVariantRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertRecurseProductRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Product (e.g. [][]Product), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseProductRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aProduct, ok := obj.(Product)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertProductRequired(aProduct)
	})
}
