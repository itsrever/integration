/*
 * Integration stubs
 *
 * Stubs for implementing a REVER integration
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"time"
)

// IntegrationOrder - Model for an Order returned by a custom integration. REVER supports multi-currency with the following restrictions:    * the shop currency must be the same for every order within the same e-commerce   * there must be only one customer currency per order (it can be the same or not than the shop currency)    
type IntegrationOrder struct {

	// Date when the Order was created in the e-commerce 
	Date time.Time `json:"date"`

	// Indicates if the taxes should be displayed as included in the total amount of the order or separated 
	TaxesIncluded bool `json:"taxes_included"`

	TotalAmount IntegrationOrderTotalAmount `json:"total_amount,omitempty"`

	TotalTaxes IntegrationOrderTotalTaxes `json:"total_taxes,omitempty"`

	Fulfillment IntegrationFulfillment `json:"fulfillment"`

	Payment IntegrationPayment `json:"payment"`

	Customer IntegrationCustomer `json:"customer"`

	Identification IntegrationIdentification `json:"identification,omitempty"`

	Shipping IntegrationShipping `json:"shipping"`

	// List of items in the order. It should only include products or services,  not shipping costs. When working with international orders, the customer currency and shop currency might be different. As REVER supports multicurrency, 2 currencies  can be specified per `line_item`. However, all of the `line_items` must have the same shop and  customer currency.  
	LineItems []IntegrationLineItem `json:"line_items"`

	ShippingAddress IntegrationOrderShippingAddress `json:"shipping_address"`

	BillingAddress IntegrationOrderBillingAddress `json:"billing_address"`
}

// AssertIntegrationOrderRequired checks if the required fields are not zero-ed
func AssertIntegrationOrderRequired(obj IntegrationOrder) error {
	elements := map[string]interface{}{
		"date": obj.Date,
		"taxes_included": obj.TaxesIncluded,
		"fulfillment": obj.Fulfillment,
		"payment": obj.Payment,
		"customer": obj.Customer,
		"shipping": obj.Shipping,
		"line_items": obj.LineItems,
		"shipping_address": obj.ShippingAddress,
		"billing_address": obj.BillingAddress,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertIntegrationOrderTotalAmountRequired(obj.TotalAmount); err != nil {
		return err
	}
	if err := AssertIntegrationOrderTotalTaxesRequired(obj.TotalTaxes); err != nil {
		return err
	}
	if err := AssertIntegrationFulfillmentRequired(obj.Fulfillment); err != nil {
		return err
	}
	if err := AssertIntegrationPaymentRequired(obj.Payment); err != nil {
		return err
	}
	if err := AssertIntegrationCustomerRequired(obj.Customer); err != nil {
		return err
	}
	if err := AssertIntegrationIdentificationRequired(obj.Identification); err != nil {
		return err
	}
	if err := AssertIntegrationShippingRequired(obj.Shipping); err != nil {
		return err
	}
	for _, el := range obj.LineItems {
		if err := AssertIntegrationLineItemRequired(el); err != nil {
			return err
		}
	}
	if err := AssertIntegrationOrderShippingAddressRequired(obj.ShippingAddress); err != nil {
		return err
	}
	if err := AssertIntegrationOrderBillingAddressRequired(obj.BillingAddress); err != nil {
		return err
	}
	return nil
}

// AssertRecurseIntegrationOrderRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of IntegrationOrder (e.g. [][]IntegrationOrder), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseIntegrationOrderRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aIntegrationOrder, ok := obj.(IntegrationOrder)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertIntegrationOrderRequired(aIntegrationOrder)
	})
}
