/*
 * Integration stubs
 *
 * Stubs for implementing a REVER integration
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"time"
)

// Order - Model for an Order returned by a custom  REVER supports multi-currency with the following restrictions:    * the shop currency must be the same for every order within the same e-commerce   * there must be only one customer currency per order (it can be the same or not than the shop currency)  In addition, discounts are supported as pre-tax calculations.  Gift cards are not considered discounts but a payment method. 
type Order struct {

	// Date when the Order was created in the e-commerce 
	Date time.Time `json:"date"`

	// Indicates if the taxes should be displayed as included in the total amount of the order or separated 
	TaxesIncluded bool `json:"taxes_included"`

	TotalAmount OrderTotalAmount `json:"total_amount"`

	TotalTaxes OrderTotalTaxes `json:"total_taxes"`

	// List of fulfillment orders per items or groups of items in the order. 
	FulfillmentOrders []FulfillmentOrder `json:"fulfillment_orders"`

	// List of returns already associated to the order 
	Returns []ReturnOrder `json:"returns"`

	// List of refunds already associated to the order. Optional, only if OPM is supported. 
	Refunds []RefundOrder `json:"refunds,omitempty"`

	Payment Payment `json:"payment"`

	Customer Customer `json:"customer"`

	Identification Identification `json:"identification,omitempty"`

	Shipping Shipping `json:"shipping"`

	// List of items in the order. It should only include products or services,  not shipping costs. When working with international orders, the customer currency and shop currency might be different. As REVER supports multicurrency, 2 currencies  can be specified per `line_item`. However, all of the `line_items` must have the same shop and  customer currency.  
	LineItems []LineItem `json:"line_items"`

	ShippingAddress OrderShippingAddress `json:"shipping_address"`

	BillingAddress OrderBillingAddress `json:"billing_address"`

	// List of notes added to the order. The notes are ordered by date, the most recent one first. They can include orders from the customer or from other third-parties, like REVER. 
	Notes []Note `json:"notes,omitempty"`
}

// AssertOrderRequired checks if the required fields are not zero-ed
func AssertOrderRequired(obj Order) error {
	elements := map[string]interface{}{
		"date": obj.Date,
		"taxes_included": obj.TaxesIncluded,
		"total_amount": obj.TotalAmount,
		"total_taxes": obj.TotalTaxes,
		"fulfillment_orders": obj.FulfillmentOrders,
		"returns": obj.Returns,
		"payment": obj.Payment,
		"customer": obj.Customer,
		"shipping": obj.Shipping,
		"line_items": obj.LineItems,
		"shipping_address": obj.ShippingAddress,
		"billing_address": obj.BillingAddress,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertOrderTotalAmountRequired(obj.TotalAmount); err != nil {
		return err
	}
	if err := AssertOrderTotalTaxesRequired(obj.TotalTaxes); err != nil {
		return err
	}
	for _, el := range obj.FulfillmentOrders {
		if err := AssertFulfillmentOrderRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Returns {
		if err := AssertReturnOrderRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Refunds {
		if err := AssertRefundOrderRequired(el); err != nil {
			return err
		}
	}
	if err := AssertPaymentRequired(obj.Payment); err != nil {
		return err
	}
	if err := AssertCustomerRequired(obj.Customer); err != nil {
		return err
	}
	if err := AssertIdentificationRequired(obj.Identification); err != nil {
		return err
	}
	if err := AssertShippingRequired(obj.Shipping); err != nil {
		return err
	}
	for _, el := range obj.LineItems {
		if err := AssertLineItemRequired(el); err != nil {
			return err
		}
	}
	if err := AssertOrderShippingAddressRequired(obj.ShippingAddress); err != nil {
		return err
	}
	if err := AssertOrderBillingAddressRequired(obj.BillingAddress); err != nil {
		return err
	}
	for _, el := range obj.Notes {
		if err := AssertNoteRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertRecurseOrderRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Order (e.g. [][]Order), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseOrderRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aOrder, ok := obj.(Order)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertOrderRequired(aOrder)
	})
}
